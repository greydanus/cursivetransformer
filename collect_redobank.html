<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwriting Stroke Capture with Automatic Word Prompts</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        button { cursor: pointer; }
        input[type="range"] { width: 100%; }
        canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const SAMPLING_INTERVAL = 2;

        const Button = ({ onClick, children }) => (
            <button
                onClick={onClick}
                style={{
                    padding: '8px 16px',
                    backgroundColor: '#2D3748',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    marginRight: '8px'
                }}
            >
                {children}
            </button>
        );

        const Input = ({ type, accept, onChange, value, placeholder, style, min, max, id }) => (
            <input
                type={type}
                accept={accept}
                onChange={onChange}
                value={value}
                placeholder={placeholder}
                style={{ ...style, padding: '4px', marginBottom: '8px' }}
                min={min}
                max={max}
                id={id}
            />
        );

        const Textarea = ({ value, readOnly, style, placeholder }) => (
            <textarea
                value={value}
                readOnly={readOnly}
                style={{ ...style, padding: '4px', width: '100%', height: '200px' }}
                placeholder={placeholder}
            />
        );

        const Label = ({ htmlFor, children }) => (
            <label htmlFor={htmlFor} style={{ display: 'block', marginBottom: '4px' }}>
                {children}
            </label>
        );

        const Slider = ({ id, min, max, step, value, onChange }) => (
            <input
                id={id}
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={onChange}
                style={{ width: '100%' }}
            />
        );

        const ErrorMessage = ({ message }) => (
            <div style={{ backgroundColor: '#FEE2E2', border: '1px solid #F87171', color: '#B91C1C', padding: '8px', borderRadius: '4px', marginBottom: '16px' }}>
                <span>{message}</span>
            </div>
        );

        const HandwritingStrokeCapture = () => {
            const [strokes, setStrokes] = React.useState([]);
            const [currentStroke, setCurrentStroke] = React.useState([]);
            const [backgroundImage, setBackgroundImage] = React.useState(null);
            const [imagePosition, setImagePosition] = React.useState({ x: 0, y: 0 });
            const [imageScale, setImageScale] = React.useState(1);
            const [isDrawing, setIsDrawing] = React.useState(false);
            const [exportedData, setExportedData] = React.useState('');
            const [author, setAuthor] = React.useState('');
            const [asciiSequence, setAsciiSequence] = React.useState('');
            const [errorMessage, setErrorMessage] = React.useState('');
            const [dataset, setDataset] = React.useState([]);
            const [wordBank, setWordBank] = React.useState([]);
            const [currentPrompt, setCurrentPrompt] = React.useState('');
            const [wordCount, setWordCount] = React.useState(1);
            const [samplingMode, setSamplingMode] = React.useState('random');
            const [startIndex, setStartIndex] = React.useState(0);
            const [currentIndex, setCurrentIndex] = React.useState(0);
            const [displayIndex, setDisplayIndex] = React.useState(0);

            const canvasRef = React.useRef(null);
            const lastPointRef = React.useRef(null);
            const lastSampledPointRef = React.useRef(null);

            const drawStrokes = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (backgroundImage) {
                    ctx.save();
                    ctx.translate(imagePosition.x, imagePosition.y);
                    ctx.scale(imageScale, imageScale);
                    ctx.drawImage(backgroundImage, 0, 0);
                    ctx.restore();
                }

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 3);
                ctx.lineTo(canvas.width, canvas.height / 3);
                ctx.moveTo(0, 2 * canvas.height / 3);
                ctx.lineTo(canvas.width, 2 * canvas.height / 3);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 2;
                strokes.forEach(stroke => {
                    if (stroke.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(stroke[0][0], stroke[0][1]);
                        stroke.forEach(point => {
                            if (point[2] === 1) {
                                ctx.lineTo(point[0], point[1]);
                            } else {
                                ctx.moveTo(point[0], point[1]);
                            }
                        });
                        ctx.stroke();
                    }
                });

                if (currentStroke.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
                    currentStroke.forEach(point => {
                        if (point[2] === 1) {
                            ctx.lineTo(point[0], point[1]);
                        } else {
                            ctx.moveTo(point[0], point[1]);
                        }
                    });
                    ctx.stroke();
                }
            }, [strokes, currentStroke, backgroundImage, imagePosition, imageScale]);

            React.useEffect(() => {
                drawStrokes();
            }, [drawStrokes]);

            const startDrawing = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                setCurrentStroke([[x, y, 1]]);
                lastPointRef.current = [x, y];
                lastSampledPointRef.current = [x, y];
                setIsDrawing(true);
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lastPointRef.current[0], lastPointRef.current[1]);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                const dx = x - lastSampledPointRef.current[0];
                const dy = y - lastSampledPointRef.current[1];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance >= SAMPLING_INTERVAL) {
                    setCurrentStroke(prev => [...prev, [x, y, 1]]);
                    lastSampledPointRef.current = [x, y];
                }
                
                lastPointRef.current = [x, y];
            };

            const endDrawing = () => {
                if (currentStroke.length > 0) {
                    setStrokes(prev => [...prev, [...currentStroke, [currentStroke[currentStroke.length - 1][0], currentStroke[currentStroke.length - 1][1], 0]]]);
                    setCurrentStroke([]);
                }
                setIsDrawing(false);
                lastPointRef.current = null;
                lastSampledPointRef.current = null;
            };

            const generateEntry = () => {
                if (!author.trim()) {
                    setErrorMessage("Please enter an author name.");
                    return null;
                }
                if (!asciiSequence.trim()) {
                    setErrorMessage("Please enter an ASCII sequence.");
                    return null;
                }
                if (strokes.length === 0) {
                    setErrorMessage("Please draw at least one stroke before adding to dataset.");
                    return null;
                }

                let allPoints = strokes.flat();
                const canvas = canvasRef.current;
                const aspectRatio = canvas.width / canvas.height;
                const normalizedPoints = allPoints.map(point => [
                    parseFloat((point[0] / canvas.width).toFixed(4)),
                    parseFloat((point[1] / canvas.height).toFixed(4)),
                    point[2]
                ]);
                
                return {
                    metadata: {author: author.trim(), asciiSequence: asciiSequence.trim(), pointCount: allPoints.length, strokeCount: strokes.length, aspectRatio},
                    points: normalizedPoints
                };
            };

            const addToDataset = () => {
                const entry = generateEntry();
                if (entry) {
                    setDataset(prev => [...prev, entry]);
                    setStrokes([]);
                    setAsciiSequence('');
                    setErrorMessage('');
                    drawStrokes();
                    return true; // Entry successfully added
                }
                return false; // Entry not added due to error
            };

            const exportDataset = () => {
                if (dataset.length === 0) {
                    setErrorMessage("The dataset is empty. Add some entries before exporting.");
                    return;
                }
                const jsonString = JSON.stringify(dataset);
                setExportedData(jsonString);
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            setBackgroundImage(img);
                            setImagePosition({ x: 0, y: 0 });
                            setImageScale(1);
                            setAsciiSequence(''); // Clear ASCII box when an image is uploaded
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleImageMove = (direction) => {
                const step = 10;
                setImagePosition(prev => {
                    switch (direction) {
                        case 'up': return { ...prev, y: prev.y - step };
                        case 'down': return { ...prev, y: prev.y + step };
                        case 'left': return { ...prev, x: prev.x - step };
                        case 'right': return { ...prev, x: prev.x + step };
                        default: return prev;
                    }
                });
            };

            const clearAll = () => {
                setStrokes([]);
                setCurrentStroke([]);
                setErrorMessage('');
                setBackgroundImage(null); // Clear the uploaded image
                setImagePosition({ x: 0, y: 0 }); // Reset image position
                setImageScale(1); // Reset image scale
                if (samplingMode === 'random') {
                    generatePrompt();
                }
                drawStrokes();
            };

            const undo = () => {
                setStrokes(prev => prev.slice(0, -1));
            };

            const loadWordBank = () => {
                // For now, we'll use a small set of words. In a real application, you'd want to load this from an API or a larger file.

                const words = ["ability", "about", "abstract", "accept", "accident", "accomplish", "account", "accurate", "achieve", "acid", "acquire", "action", "action", "active", "actor", "actual", "adapt", "addition", "adjust", "admire", "adopt", "adult", "advantage", "adventure", "advertise", "advice", "aerobic", "affair", "affect", "afraid", "again", "agent", "barter", "basket", "battle", "beautiful", "begin", "behind", "believe", "belt", "benefit", "best", "betray", "better", "between", "bicycle", "biding", "bike", "bind", "biology", "bird", "birth", "bitter", "blanket", "blast", "calculate", "capital", "captain", "carton", "castle", "cater", "catch", "category", "cattle", "ceiling", "celebrate", "cement", "century", "certain", "chain", "chair", "chapter", "daily", "data", "date", "daughter", "daring", "debate", "debt", "decide", "decline", "decorate", "define", "deliver", "demise", "denial", "dentist", "depart", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "despair", "destroy", "detail", "detect", "earth", "easily", "east", "eat", "educate", "effect", "effort", "egging", "eight", "either", "electric", "elegant", "element", "elevator", "elite", "emotion", "empty", "enact", "engine", "enjoy", "fact", "fail", "fair", "faith", "family", "fantastic", "farther", "fashion", "fast", "fated", "fatal", "father", "fatigue", "fault", "favorite", "feature", "festival", "fetch", "fiber", "fiction", "field", "fierce", "fight", "figure", "file", "fill", "film", "final", "find", "gain", "galaxy", "gaping", "garlic", "gather", "genius", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glide", "glimpse", "goat", "gorilla", "gossip", "habit", "hair", "harvest", "hatter", "hater", "health", "heart", "height", "helmet", "hidden", "high", "hill", "hint", "hippo", "hire", "history", "holiday", "ice", "idea", "ideal", "ignore", "illness", "illegal", "imagine", "imitate", "immediate", "impact", "implement", "important", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "intend", "interest", "interior", "into", "invent", "jacket", "jail", "jammer", "jar", "jawful", "jazz", "jeans", "jelly", "jewel", "jobber", "join", "joke", "journal", "journey", "joyful", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "justice", "justify", "ketchup", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knife", "laptop", "last", "late", "lawsuit", "lecture", "left", "leisure", "length", "letter", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "lobster", "logic", "lottery", "luxury", "lyrics", "machine", "magic", "magnet", "maid", "mail", "main", "major", "mandate", "mansion", "margin", "marine", "market", "marriage", "master", "match", "material", "math", "matrix", "matter", "maximum", "meaty", "mechanic", "media", "medical", "meeting", "melt", "mention", "merit", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "nail", "nation", "nature", "neat", "negative", "negotiate", "neighbor", "neither", "nest", "net", "network", "neutral", "next", "nice", "night", "noise", "nominee", "north", "notable", "note", "nothing", "notice", "neither", "oasis", "object", "oblige", "obtain", "obvious", "october", "office", "often", "oiled", "oldest", "olive", "olympic", "omit", "onion", "online", "opinion", "option", "orbit", "ordinary", "orient", "original", "ostrich", "other", "outdoor", "outer", "output", "outside", "pain", "paint", "pair", "panting", "panic", "parent", "parrot", "party", "patch", "path", "patient", "patrol", "pattern", "payment", "peanut", "peasant", "pelican", "penalty", "pencil", "perfect", "permit", "petting", "photo", "physical", "piano", "picnic", "picture", "quality", "quantity", "quarter", "question", "quick", "quiet", "quit", "quiz", "quote", "rabbit", "radio", "rail", "rain", "raise", "rapid", "rate", "rather", "react", "rebuild", "receive", "recipe", "reflect", "region", "regret", "reject", "relax", "relief", "remain", "remind", "rent", "repair", "repeat", "report", "resist", "result", "retire", "retreat", "return", "reunion", "review", "rhythm", "ribbing", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "satisfy", "sail", "salt", "satellite", "satisfy", "scatter", "science", "scissors", "scorpion", "scout", "script", "seat", "secret", "section", "security", "segment", "select", "seminar", "senior", "table", "tackle", "tagged", "tail", "take", "tale", "talk", "tall", "tank", "tapped", "target", "task", "taste", "taxing", "teach", "team", "tell", "tenths", "tenant", "tennis", "tent", "term", "testing", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thick", "thin", "thing", "think", "third", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "ultimate", "understand", "unfair", "uniform", "unique", "unit", "universe", "until", "unveil", "update", "upset", "utility", "vacant", "vacation", "vaccine", "valid", "vanity", "vanish", "various", "vast", "vault", "vehicle", "velvet", "venture", "verify", "version", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visas", "visit", "visual", "vital", "vivid", "voice", "voided", "vote", "wait", "walnut", "want", "waste", "watch", "water", "waylaid", "wealth", "weather", "webbing", "wedding", "weird", "west", "wetted", "what", "wheat", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "winging", "winked", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "xylophone", "xerox", "xenon", "xenophobia", "xerography", "xmases", "xrays", "xylem", "xanthic", "xanadu", "xenial", "xenolithic", "xerophyte", "xylocarp", "xiphoid", "xiphosura", "xenograft", "xerosis", "xylograph", "xyster", "xystus", "xebec", "xenogenesis", "xenolith", "xerophilous", "xiphias", "xylophone", "xylorimba", "xanthoma", "xenomorph", "xerarch", "xeroderma", "xiphosura", "xylocopa", "xylitol", "xystus", "xanthophyll", "xenomania", "xerophagous", "xiphoid", "xyster", "xylol", "xylose", "xanthous", "xenon", "xerox", "yesterday", "yet", "yield", "yogurt", "youth", "yawning", "yeast", "yetis", "yogurt", "youthful", "youth", "yacht", "yakking", "yeast", "yenning", "yield", "yippee", "yurts", "zenith", "zesty", "zigzag", "zinc", "zip", "zucchini", "zeppelin", "zeta", "zipper", "zodiac", "zombie", "zucchini", "zygote", "zealot", "zenith", "zeppelin", "zest", "zestful", "zigzag", "zinc", "zinger", "zinnia", "zipping", "zircon", "zodiac", "zombie", "ciodzjs", "eximmarz", "aiashrl", "hremelkis", "vruil", "xnse", "zgirhahla", "neehjboarp", "hnetesnu", "fjhlpxa", "imntroa", "eeeipef", "jttarrr", "rzvt", "redetie", "ront", "zenrdtr", "oottepe", "sttn", "qrthn", "vtyeh", "esihoo", "nseczaei", "tchr", "ozztltseo", "kgnt", "twtai", "itqhfrnyee", "enibebyuty", "aoaytmofdt", "lgesdjtasye", "ebnnine", "esfwlicm", "hiimeleiu", "teej", "iatqnexl", "yatain", "temhwompd", "ediy", "niclesdd", "evhig", "lsxeenh", "tux", "xjteswhgr", "aieteyz", "hettaiskrto", "edjea", "hoteel", "izlaz", "hihknxf", "thteh", "dtt", "zpsnkioao", "lpsdqrnvlt", "tijsgie", "datej", "tuala", "rtslshc", "aie", "mytb", "ivet", "lielnmdtha", "stoeh", "leaintashr", "etlebusu", "trorez", "prntzr", "aatexa", "indett", "bsta", "ztqot", "hqjsi", "tiemae", "jdzylr", "mxra", "viee", "tasteen", "ehoejj", "qaiy", "eiae", "toiawh", "wssj", "wtknlomos", "utie", "uuix", "mettwti", "dtiyzrte", "sjnnts", "dreeielrid", "cneilgy", "tomuses", "utqwt", "tnyeeoo", "tetnsmbcr", "eomim", "tiwxmee", "rjvs", "vptlc", "ueni", "irbaelwdzl", "pmislvs", "kgfyi", "teeanrs", "rptvtn", "rtetnwgv", "dldleithetg", "tabastja", "worrlhi", "hitrc", "htagmrh", "haeie", "pvtwcr", "edbnt", "xeno", "cfttez", "frgtoa", "havbbta", "ofvaiesd", "syaiqtg", "tknnds", "isnwtdl", "kcrt", "ifivqgoqhs", "sdltacpt", "ggxghfarj", "dmoutfeu", "tsannsttlsy", "aeim", "kttepig", "twcl", "runft", "viogoe", "alaatei", "tkxgd", "aekrir", "aii", "ecxrntpn", "srrtz", "letu", "eeabgitrw", "ntee", "nknbstso", "neseii", "qadnret", "iens", "tjeo", "elueiss", "ookj", "xpon", "peolegib", "hnfesiez", "htieteoot", "sot", "rwot", "mxaa", "otcm", "axjcque", "sidhekaai", "iisitzlm", "sntss", "ancrdwlrte", "etjottba", "iiurnansr", "thoilrw", "wtsraa", "ewtgsvk", "lcnft", "ietetbhn", "eotaeo", "eeet", "ctturn", "iwoiscean", "irmbs", "oeeet", "xxeuahakrz", "ehqaaqt", "clovfjaor", "loi", "ioht", "mutf", "uytoteoj", "oqyebnt", "iithot", "thrlnrsjo", "tlm", "naxvzvydeoa", "spmxn", "nuzi", "vctb", "txotyt", "ktaw", "sqinn", "asscrttfre", "jst", "hurtlzeeww", "ntio", "iev", "mretehj", "fodhviebm", "medetoa", "akgtdwat", "ypmt", "wlihcc", "etvca", "dtegts", "ziek", "ajaibetrhcn", "aete", "ttrb", "stosiwe", "dsfleux", "tdiixev", "lotxd", "eoelgovisoh", "fqtt", "sutei", "nknngxa", "moiexih", "xlalawlx", "tesdnigt", "lshluezbst", "hreroet", "nicmsaso", "azsnghih", "krwvoxrs", "ajavnbggzio", "teos", "qazatctef", "otmlaono", "thnehs", "eoj", "auxsqmr", "xcdq", "ynbj", "fsqiax", "deoje", "othvegde", "aiauonty", "lrstl", "odlidi", "ztfuo", "dobtwcdf", "tkcrkidb", "ebshafoeia", "ecetrnicn", "tmvst", "ttsveo", "iitipteo", "yertesklpr", "rjinaqpvde", "eoriaielhst", "iyeda", "ddkioey", "apkt", "tearteywsf", "tocemg", "roeajttt", "ltaioyah", "yuebt", "edztidtb", "euiie", "shsnlftr", "eabaaeooid", "amidc", "tiwbiv", "hskeis", "eenewonj", "ykimho", "bpsta", "kwhli", "refmato", "kxtereo", "uexbt", "seislaez", "ruhzigr", "eeoepi", "peit", "vhttyawkrho", "ttanea", "prqt", "hsbi", "oaatla", "kafxtcaeh", "lrsttwa", "rktn", "ilhfqxnl", "eespeaax", "edjzoesw", "onaqht", "ywfvttitn", "osjrp", "resaiaxde", "kstds", "ttwaaceli", "vhxtoesrzeh", "tkdsyo", "natme", "etna", "hraii", "sioaaa", "xzimttk", "ecicy", "httges", "oaai", "ghcaeiu", "hgrakjede", "owajtolx", "rinzooet", "mtepl", "clnjk", "tivn", "ahiua", "rio", "rmhvszllisa", "woineb", "aubet", "decohat", "xegxvmy", "saste", "sxet", "tfxxrnxg", "wnoojgtjtz", "wideiairih", "airn", "mmgthriylq", "eiudf", "kxdnm", "iaoiliqcve", "indg", "tatx", "eilnkac", "seweei", "utpcveut", "lbrhheneiht", "otgzot", "rttf", "yxfengnont", "ejkqsdr", "eiwfwao", "aefiat", "etsmi", "ihaa", "anrt", "zudtaj", "gisem", "idei", "eyddrcnfin", "raidnh", "nta", "srj", "katsa", "pihcja", "tsbtextea", "ozezsyt", "eesfta", "xskjzh", "mett", "vatshoee", "tamaxn", "tmbcxo", "badctix", "tttwoter", "ustl", "htqstdns", "noalioon", "lieesih", "aieaaatrwor", "roattthce", "otayjl", "hxoafutise", "eyhnssjnt", "tpt", "esot", "ziutnan", "tebnasm", "irwhse", "aat", "zesyilah", "tbroocis", "ati", "sepbtd", "rinyos", "uzt", "eegoet", "ycnt", "iywmt", "ovqaghik", "oolmia", "twbcan", "nsyheei", "rwiipnaoln", "iaqsliels", "iuha", "idqnidz", "tswtrwem", "tdsdb", "jkgld", "rheaiv", "mlziies", "ronxre", "ntrc", "tjsexive", "eaisueo", "eeti", "dadhrj", "teayooep", "iptsnic", "eeqiso", "vicaiar", "tftbsl", "wttx", "oettonkp", "ktkow", "aonvtia", "artcbnn", "aepzaetzy", "nwairxii", "asxvohrete", "taxhno", "ihtlvapiov", "izaheteaq", "htn", "ikfbn", "temm", "toag", "aoxatdd", "uhlei", "whfet", "neretnwpnn", "wiehseh", "sij", "qjuyhr", "oitttfaqsnh", "eainne", "whntdty", "cvlukri", "taden", "etj", "rhlvnte", "ainxq", "xsve", "tavetdct", "joriviee", "skbumtha", "elaejv", "evlnmut", "gia", "satiazmnys", "jgaomyea", "wevjns", "ethptd", "iomaahi", "pnerpate", "jfixrtisoi", "eapecj", "ndyrcmtil", "tooxfscocou", "hrifonj", "xmidbroee", "yhttpue", "frqrtnuaemg", "rnljhv", "kneri", "eihieqye", "dat", "nlis", "rleiutll", "bjoss", "elnfatlrlh", "inhoclar", "eftn", "qeet", "tsjelrhe", "ttec", "ojtdehdep", "sfshgrts", "towhia", "yihzs", "cillfheo", "tewenmsmje", "ijfaxunfc", "teteuaeai", "motqcis", "hdirciplmn", "izeadg", "yassjjta", "hcdawifhp", "bbetid", "tdteee", "ydtu", "wtlliv", "zeteawp", "gonqeitnre", "ertsocan", "geateguvat", "icr", "whjsaaedat", "glmltm", "nucnrabntt", "tntdltss", "aohmts", "tumok", "imrrdlooy", "tgte", "eoxrt", "blffbfieb", "nht", "ddaihiau", "ofetlttao", "theeh", "mzwtjsedei", "hxgeoo", "kygdnkoinc", "moddjsthie", "tfyshwiba", "elmi", "drwhsiliexy", "ntllnwu", "seqverdtrrl", "pdrth", "exusfe", "afexnmea", "oeej", "zmtateek", "titwamd", "ithbdnr", "kreeiilhvi", "neth", "pwstws", "holia", "tthdehie", "eosri", "piije", "taeazw", "afjrta", "tgptd", "uciwyntdst", "seinsrqau", "axwh", "hyeci", "sapsbxsetsr", "isn", "ermia", "natcd", "itamt", "oylin", "lzvsnttro", "ejiedht", "awet", "iyh", "qechatus", "srvxzy", "gtsp", "sjmeeecore", "trkxhq", "tdma", "jvl", "lilsh", "uatohnfmvdh", "hetjholum", "ssxlhrzope", "ihet", "ejeext", "eiafi", "urath", "teqodttttqs", "ttffjhys", "oox", "undnxqte", "watlqkdd", "edishd", "xztttrioi", "sttb", "eeiot", "vjye", "tcewkq", "htflsek", "dtejtdetlgp", "entihzkx", "outs", "eetda", "datlr", "tsa", "fitdodras", "ielsweiew", "tulmsxle", "srt", "iesedext", "sefysie", "eanrite", "detdw", "ujaqwrsjtes", "sylpri", "zntlalrosn", "cieheg", "liohs", "hoetpueo", "lftilviehh", "ejsfetl", "txzo", "tekdkd", "tce", "siroxtdspxn", "hjuo", "tkmhy", "ihtrs", "teh", "ehwt", "eaai", "gtaeoto", "trnl", "tew", "llif", "eeftr", "regts", "uwdsddiy", "dfjuj", "umochjtxn", "lftx", "voxiegyee", "utro", "kkxais", "teaasea", "tomth", "isic", "vteet", "athm", "idanesw", "eime", "hty", "lth", "tdwuat", "veqqjeccz", "rnhtjnukee", "ioe", "lhhtvee", "ufonj", "zcrt", "eetpilohitc", "eli", "ikhhhd", "aomt", "jif", "ehott", "tenec", "qdif", "mtfrem", "aci", "xsomegslex", "rtahu", "teereor", "vzehrt", "eotatrkbg", "sife", "aisoh", "wxby", "toon", "iziohquts", "fta", "eied", "qoteubh", "tklae", "xdekltfia", "zeredqli", "denetsqtetw", "gtm", "tbsohsqx", "knei", "phdxieuh", "efqezcto", "agfqndcjw", "rmlrt", "ereeohlcia", "ntoed", "iissh", "noleio", "uctorwerd", "ejet", "itrhvenis", "pjkj", "nisp", "tnbe", "syddnxvro", "rafbai", "njsca", "iwtzs", "tpchdhlbt", "otb", "onesoiy", "eqdhlte", "isrzq", "siedxinm", "htlrt", "fefbtetq", "lxmy", "tez", "nwetts", "othsws", "fzi", "wcilfmtn", "bjen", "otkey", "phrlriji", "tniaega", "eotsi", "xrip", "optealweh", "islilr", "yetibr", "ate", "dzhtug", "tihtprcqka", "itn", "widenle", "usbdsortyht", "oeluihk", "caihatras", "aidteadi", "tntaustkta", "fwninnt", "rslt", "jpeaor", "ctqw", "aqtafes", "ttaxi", "intehselimt", "gdshexeeh", "tehadhzks", "irenhmesd", "seinibsjk", "xrqk", "drt", "tktayv", "dietp", "setdnqr", "ejidts", "jeeohpd", "jige", "mxdn", "wapdxvtre", "pjfhz", "uai", "ikttniaaj", "ietnrmsrgg", "taooewtelkh", "hntiieocr", "epedski", "mfekithtlo", "ikte", "saast", "kajdeiff", "uverelrnat", "itmr", "otzcv", "cgildsnbd", "hniohieth", "etdvnodog", "jaawb", "vhsnasfhtrt", "hdcie", "sih", "ttay", "xbes", "kesasi", "eiev", "yttiiqlrv", "klwmwi", "tidttsetr", "ocei", "hbt", "fio", "dhittix", "kdrtt", "tsr", "dtmm", "rretrv", "neyopnix", "eblj", "aesjfzan", "ceavx", "ovaybtye", "asisbpeoe", "tdmwe", "wxom", "treizao", "tihshhc", "etktydrsraf", "otff", "teub", "koexojaywl", "limtaorfdl", "uatat", "uenia", "ttegp", "xbhaf", "amsshinnf", "djnxtjaxh", "otknt", "oeir", "iipl", "ruedstgt", "ltul", "atfttr", "iqth", "sin", "ediwh", "aeeiunvk", "oijrf", "ogtnji", "guteu", "raeeio", "ngkaia", "sfin", "ieiswdr", "nnynaljvoe", "phjj", "retags", "trhlo", "nnslte", "kaia", "hltbtkeeh", "eisp", "qnsabdiuee", "ugiw", "eioengh", "mbyti", "qxehaohi", "dtndrie", "igtseoahcj", "sib", "tmxeo", "minzgsrah", "atsnde", "entw", "itv", "lepriaaset", "ndvdlxdb", "iisx", "aast", "gstpqeotri", "tsioobn", "otilui", "xdhd", "eanaoaht", "nenetjg", "ltoyht", "snahgqei", "awxsekn", "musia", "ncelianl", "lqgt", "jbatp", "kjssu", "teemeuk", "tjxo", "wcwderdztu", "pkvsvzsaxg", "rate", "eeuealtokd", "ersdgtlt", "robt", "iizth", "tybrh", "jesxtgb", "otartvi", "wrtettvoi", "rqrmsxt", "fyanptuhue", "ezjnr", "eei", "tjqaod", "eihsfih", "rtnoaee", "usirils", "trpo", "ltnhiaa", "taa", "jhrqd", "tdrcwjixd", "eetnjrrh", "enatgovd", "ttr", "tlhds", "ttftlpoe", "oqhetse", "oetfaj", "eqont", "cdjkzmlble", "ermhsaii", "mslx", "txjtsz", "qisi", "xnie", "hoatpn", "heise", "hwje", "erlrint", "ekhvwxaee", "stzthve", "tmnrd", "tawoesep", "tyvne", "dtnttwil", "dbagtdcit", "utly", "itezm", "pndneromxvc", "tene", "hwi", "esrkt", "ibsi", "wrst", "xgzmhiyi", "krboethaws", "joeyehiorp", "pti", "usnaojteb", "itse", "tzabbnu", "msavat", "orinftet", "ida", "ootzerez", "onrheodt", "ubigim", "xnashvqn", "etetadae", "qolli", "htukfnaue", "ireg", "ieoatoma", "ewahtne", "soieutitenq", "dhta", "tuw", "iewjoib", "thiwl", "ohj", "dwxns", "oioap", "sjq", "chegtnr", "ipt", "eafi", "aviitre", "nwki", "sriauur", "sispz", "fetsnye", "tihoweoo", "eyiozeeh", "honhio", "teethi", "ortlr", "mtohkrqv", "drtnki", "mvtv", "oigievdps", "sptlke", "itiurs", "critnfe", "rttiwaitv", "zfffxuaf", "isseo", "rxhsrmuwdxi", "tylulmxcl", "tsre", "lhslta", "ssat", "iaeyowmhe", "volj", "tntgrseileo", "aoyhyqnyipb", "aejel", "thtspeh", "htro", "imemdqb", "ltk", "ciee", "ctjina", "tised", "leio", "efneiaoi", "ito", "hohioner", "argx", "driened", "aihn", "tsxf", "ttrh", "fufetls", "atskrh", "rtet", "etsedti", "nvghajd", "iiqdsee", "teqks", "nbt", "lxtvwm", "kjaacgei", "utoeesg", "ojaxh", "yfliet", "nimrt", "asi", "aideezsxi", "oojxvqsa", "aite", "izcunj", "vgri", "zttyin", "celtbxs", "jsstcbxnc", "tndssd", "kestetseiua", "iiwi", "bimwahs", "ltjhfkltwck", "bsis", "elot", "zlet", "aeqtz", "neegtgh", "xenh", "tmatroqbl", "scaghejg", "tfnou", "nwnexoboww", "rlxxi", "otgec", "ejssh", "hrta", "igehfrfee", "teoaoco", "eilat", "elltds", "uxdaerf", "gaiokrhyan", "fptrwwdsa", "vgtqsetfw", "tehy", "eetitarwe", "aath", "endnxddt", "rtdaavit", "eunx", "ocubt", "ototi", "yplieey", "hotsrceb", "ruitnevme", "xcmlb", "aato", "trj", "hjuta", "tnero", "sljca", "iaolo", "peeta", "oies", "shcytea", "hjtqsdik", "qeeqtvnte", "attlthhx", "zaiwvtf", "aetcci", "nshyhx", "tsgt", "hqmgrnhi", "ttdtam", "mslrmerx", "attreea", "hahttqy", "epidari", "ics", "xteenpeal", "bsjsrox", "oyiigze", "uusi", "eiidqeaie", "eooimeea", "exsea", "deqatioaer", "zbjd", "tswsr", "otcauaka", "cnwii", "enwftertteo", "ihihete", "vnahi", "ihitl", "atr", "zstt", "iuslu", "itlh", "tnhzere", "tegbrtd", "gdmtk", "oiee", "ekt", "cnntdza", "dooette", "tea", "igelu", "iutb", "nnotyr", "uomhit", "ttcjv", "gpsoadsit", "jvao", "tqej", "pslcajzl", "eaioqas", "thergliahx", "iiszo", "tmsa", "jtezatrhjt", "hsoiowsjhl", "hehjeo", "nisi", "otasn", "waeie", "chirlstottr", "ytee", "etfbm", "hieaquonip", "wnnirece", "imqk", "tht", "giaw", "hiafntyoc", "toipte", "aawowmx", "eoirj", "awset", "ihjfstt", "nnafehi", "edtnane", "rdflim", "ixgjcgfle", "pdetaaacdo", "goidnbjd", "intlt", "hvnttx", "keeoie", "twnee", "heiqttt", "jri", "njyt", "yvat", "stanarubmha", "saawt", "ieeeevf", "safrlajewbd", "zegic", "ewchncdtn", "tqtsen", "iqhtx", "tdlixigq", "iaihg", "twho", "azliinoise", "dgoelhx", "ajeonq", "rnxe", "eisop", "foadit", "taiierp", "erquxbeie", "stmiuepi", "chedtcla", "cosojstv", "sttv", "huxoh", "swtp", "autgeve", "kexje", "irhqa", "vkci", "nlint", "sstveaasg", "tcthgii", "hhdhpdeojsw", "keboceinfs", "deexmefte", "rcxe", "iionh", "otnty", "xojocowt", "nawtsduets", "xhdteanr", "uibedv", "sratqahkt"];
                setWordBank(words);
            };

            const generatePrompt = () => {
                if (wordBank.length === 0) return;

                    let prompt;
                    if (samplingMode === 'random') {
                        prompt = Array(wordCount).fill().map(() => wordBank[Math.floor(Math.random() * wordBank.length)]).join(' ');
                        setCurrentPrompt(prompt);
                    } else {
                        prompt = Array(wordCount).fill().map(() => {
                            const word = wordBank[currentIndex];
                            
                            setCurrentIndex((prevIndex) => {
                                const newIndex = (prevIndex + 1) % wordBank.length;
                                setDisplayIndex(newIndex);
                                return newIndex;
                            });

                            return word;
                        }).join(' ');
                        setCurrentPrompt(prompt);
                    }
                    if (samplingMode === 'random') {
                        setCurrentPrompt(prompt);
                    }
                setAsciiSequence(prompt); // Populate ASCII box with the prompt
            };

            React.useEffect(() => {
                loadWordBank();
            }, []);

            React.useEffect(() => {
                if (samplingMode === 'random') {
                    generatePrompt();
                } else if (wordBank.length > 0) {
                // For ordered mode, generate prompt once when wordBank is loaded
                    generatePrompt();
                }
            }, [samplingMode, wordCount, wordBank]);


            return (
                <div className="container">
                    <h2 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '16px' }}>Handwriting Stroke Capture</h2>
                    <p style={{ fontSize: '14px', color: '#4B5563', marginBottom: '16px' }}>
                        Instructions: Upload an image, trace the writing, enter author and ASCII sequence, then add to dataset. Export when finished.
                    </p>
                    {errorMessage && <ErrorMessage message={errorMessage} />}
                    <Input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ marginBottom: '16px' }}
                    />
                    <div style={{ marginBottom: '16px' }}>
                        <Label htmlFor="word-count">Number of Words in Prompt</Label>
                        <Input
                            id="word-count"
                            type="number"
                            min="1"
                            max="10"
                            value={wordCount}
                            onChange={(e) => {
                                const newWordCount = parseInt(e.target.value);
                                setWordCount(newWordCount);
                                 // Generate a new prompt only for random mode
                                 // or if it's the initial load for ordered mode
                                setTimeout(() => generatePrompt(), 0);
                            }}
                        />
                    </div>
                    {currentPrompt && (
                        <div style={{ 
                            marginBottom: '16px'
                        }}>
                            {currentPrompt}
                        </div>
                    )}
                    <canvas
                        ref={canvasRef}
                        width={1200}
                        height={200}
                        onMouseDown={startDrawing}
                        onMouseMove={draw}
                        onMouseUp={endDrawing}
                        onMouseOut={endDrawing}
                        style={{ border: '1px solid #CBD5E0', cursor: 'crosshair', marginBottom: '16px', maxWidth: '100%' }}
                    />

                    <div style={{ marginBottom: '16px' }}>
                        <Label htmlFor="sampling-mode">Sampling Mode</Label>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Input
                                id="sampling-mode"
                                type="checkbox"
                                checked={samplingMode === 'ordered'}
                                onChange={(e) => {
                                    setSamplingMode(e.target.checked ? 'ordered' : 'random');
                                    setCurrentIndex(startIndex);
                                }}

                                style={{ marginRight: '8px' }}
                            />
                            <span>Ordered</span>
                        </div>
                    </div>
                    {samplingMode === 'ordered' && (
                        <div style={{ marginBottom: '16px' }}>
                            
                            <Label htmlFor="start-index" style={{ marginRight: '8px' }}>
                            {`Word Bank Index (current: ${displayIndex}/${wordBank.length})`}
                            </Label>
                            <Input
                                id="start-index"
                                type="number"
                                min="1"
                                max={wordBank.length}
                                value={startIndex+1}
                                onChange={(e) => {
                                    const newIndex = Math.max(0, Math.min(parseInt(e.target.value) - 1, wordBank.length - 1));
                                    setStartIndex(newIndex);
                                    setCurrentIndex(newIndex);
                                    setDisplayIndex(newIndex);
                                }}

                            />
                        </div>
                    )}

                    <div style={{ marginBottom: '16px' }}>
                        <p style={{ fontSize: '14px', color: '#4B5563', marginBottom: '8px' }}>Image Positioning Controls:</p>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px', marginBottom: '8px' }}>
                            <Button onClick={() => handleImageMove('up')}>↑</Button>
                            <Button onClick={() => handleImageMove('down')}>↓</Button>
                            <Button onClick={() => handleImageMove('left')}>←</Button>
                            <Button onClick={() => handleImageMove('right')}>→</Button>
                        </div>
                        <div>
                            <Label htmlFor="scale-slider">Image Scale</Label>
                            <Slider
                                id="scale-slider"
                                min={0.1}
                                max={2}
                                step={0.1}
                                value={imageScale}
                                onChange={(e) => setImageScale(parseFloat(e.target.value))}
                            />
                        </div>
                    </div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '16px' }}>
                        <div>
                            <Label htmlFor="author-input">Author</Label>
                            <Input
                                id="author-input"
                                value={author}
                                onChange={(e) => setAuthor(e.target.value)}
                                placeholder="Enter author name"
                            />
                        </div>
                        <div>
                            <Label htmlFor="ascii-input">ASCII Sequence</Label>
                            <Input
                                id="ascii-input"
                                value={asciiSequence}
                                onChange={(e) => setAsciiSequence(e.target.value)}
                                placeholder="Enter ASCII sequence"
                            />
                        </div>
                    </div>
                    

                    <div style={{ display: 'flex', flexDirection: 'column', gap: '16px', marginBottom: '16px' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Button onClick={() => { clearAll(); }}>Clear All</Button>
                            <Button onClick={undo}>Undo</Button>
                            {samplingMode === 'ordered' && (
                                <Button onClick={generatePrompt}>Next Word</Button>
                            )}
                            <Button onClick={() => {
                                const success = addToDataset();
                                if (success && samplingMode === 'ordered') {
                                    setDisplayIndex((currentIndex + 1) % wordBank.length);
                                    generatePrompt();
                                } else if (success && samplingMode === 'random') {
                                    generatePrompt();
                                }
                            }}>Add to Dataset</Button>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Button onClick={exportDataset}>Export Dataset</Button>
                            <span style={{ fontSize: '14px', color: '#4B5563' }}>
                                Dataset size: {dataset.length} entries
                            </span>
                        </div>
                    </div>



                    {exportedData && (
                        <Textarea
                            value={exportedData}
                            readOnly
                            placeholder="Exported dataset will appear here"
                        />
                    )}
                </div>
            );
        };

        ReactDOM.render(<HandwritingStrokeCapture />, document.getElementById('root'));
    </script>
</body>
</html>